library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;

entity RAM_STATE is
	port(
		clk : in std_logic;
		rst : in std_logic;
		new_word_rx : in std_logic; --lo que va a habilitar la maquina de estados --lap_btn
		word_rx : in std_logic_vector(7 downto 0); --palabra que entra de la uart a la maquina de estados
		rsta_ram : out std_logic; --salida de reset a la ram
		ena_ram : out std_logic; --salida de enable a la ram
		wea_ram : out std_logic_vector(0 downto 0); --salida de escritura a la ram
		address_out : out std_logic_vector(7 downto 0);
		ramstate : OUT std_logic_vector(3 downto 0);
		data_out : out std_logic_vector(7 downto 0)
	);
end RAM_STATE;


architecture Behavioral of RAM_STATE is
	type state_type is (idle_state, reset_state, write_address_state, write_data_state, ready_state);
	signal state, next_state : state_type;
	signal address : std_logic_vector(7 downto 0) := (others => '0');
	signal data : std_logic_vector(7 downto 0) := (others => '0');

begin
	clock: process (clk, rst)
	begin
		if(rst = '1') then
			state <= idle_state;
		elsif rising_edge(clk) then
			state <= next_state;
		end if;
	end process clock;
	
	output: process (state)
	begin
		if state = idle_state then
			rsta_ram <= '0';
			ena_ram <= '1';
			wea_ram(0) <= '0';
			ramstate <= "0000";
		elsif state = reset_state then
			rsta_ram <= '1';
			ena_ram <= '0';
			wea_ram(0) <= '0';
			ramstate <= "0001";
		elsif state = write_address_state then
			rsta_ram <= '0';
			ena_ram <= '0';
			wea_ram(0) <= '0';
			ramstate <= "0010";
		elsif state = write_data_state then
			rsta_ram <= '0';
			ena_ram <= '1';
			wea_ram(0) <= '1';
			ramstate <= "0011";
			address_out <= address;
			data_out <= data;
		elsif state = ready_state then
			rsta_ram <= '0';
			ena_ram <= '0';
			wea_ram(0) <= '0';
			ramstate <= "0100";
		end if;
	end process output;
	
	next_state_logic: process (state, new_word_rx, word_rx, address, data)
	begin
		next_state <= state;
		case (state) is
			when idle_state =>
				if new_word_rx = '1' then
					if word_rx = "00000001" then --empezar el modo bootloader
						next_state <= reset_state;
					end if;
				end if;
			when reset_state =>
				if new_word_rx = '1' then
					if word_rx = "00000010" then --avisa que va a mandar una direccion
						next_state <= write_address_state;
					end if;
				end if;
			when write_address_state =>
				if new_word_rx = '1' then
					if word_rx = "00000011" then
						next_state <= ready_state;
					else
						address <= word_rx; ---salida
						next_state <= write_data_state;
					end if;
				end if;
			when write_data_state =>
				if new_word_rx = '1' then
					data <= word_rx; ---salida
					next_state <= write_address_state;
				end if;
			when ready_state => --reiniciar el micro
				next_state <= idle_state;
			when others =>
				next_state <= state;
		end case;
	--address_out <= address;
	--data_out <= data;
	
	end process next_state_logic;
	
	--address_out <= address;
	--data_out <= data;

end Behavioral;

