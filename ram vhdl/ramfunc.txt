library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;

entity RAM_STATE is
	port(
		clk : in std_logic;
		rst : in std_logic;
		lap_btn : in std_logic;
		en : in std_logic;
		stp : in std_logic;
		en_out : out std_logic;
		stp_out : out std_logic
	);
end RAM_STATE;


architecture Behavioral of RAM_STATE is
	type state_type is (idle_state, write_state, read_state);
	signal state, next_state : state_type;

begin
	clock: process (clk)
	begin
		if(clk'event and clk = '1') then
			if(rst = '1') then
				state <= idle_state;
			else
				state <= next_state;
			end if;
		end if;
	end process clock;
	
	output: process (state)
	begin
		if state = idle_state then
			en_out <= '0';
			stp_out <= '0';
		elsif state = write_state then
			en_out <= '1';
			stp_out <= '0';
		elsif state = read_state then
			en_out <= '0';
			stp_out <= '1';
		else
			en_out <= '0';
			stp_out <= '0';
		end if;
	end process output;
	
	next_state_logic: process (state, lap_btn, en, stp)
	begin
		next_state <= state;
		case (state) is
			when idle_state =>
				if lap_btn = '1' then
					if en = '1' then
						next_state <= write_state;
					elsif stp = '1' then
						next_state <= read_state;
					end if;
				end if;
			when write_state =>
				if lap_btn = '1' then
					if en = '1' then
						next_state <= state;
					elsif stp = '1' then
						next_state <= read_state;
					end if;
				end if;
			when read_state =>
				if lap_btn = '1' then
					if en = '1' then
						next_state <= write_state;
					elsif stp = '1' then
						next_state <= state;
					end if;
				end if;
			when others =>
				next_state <= idle_state;
		end case;
	end process next_state_logic;

end Behavioral;

